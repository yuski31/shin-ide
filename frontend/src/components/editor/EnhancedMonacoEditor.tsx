import React, { useRef, useEffect, useState, useCallback } from 'react';
import Editor, { OnMount, OnChange } from '@monaco-editor/react';
import * as monaco from 'monaco-editor';
import { useTheme } from '../../hooks/useTheme';
import { useWebSocket } from '../../hooks/useWebSocket';
import { useAIStore } from '../../store/useAIStore';

interface EnhancedMonacoEditorProps {
  value: string;
  language: string;
  path: string;
  projectId: string;
  onChange?: (value: string, changes: any[]) => void;
  onSave?: (value: string) => void;
  readOnly?: boolean;
  className?: string;
  enableAI?: boolean;
  enableCollaboration?: boolean;
}

interface AICompletion {
  text: string;
  range: monaco.IRange;
  confidence: number;
}

export const EnhancedMonacoEditor: React.FC<EnhancedMonacoEditorProps> = ({
  value,
  language,
  path,
  projectId,
  onChange,
  onSave,
  readOnly = false,
  className = '',
  enableAI = true,
  enableCollaboration = true,
}) => {
  const editorRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null);
  const { theme } = useTheme();
  const { socket, isConnected } = useWebSocket();
  const [isReady, setIsReady] = useState(false);
  const [isLoadingCompletion, setIsLoadingCompletion] = useState(false);
  const [aiCompletions, setAiCompletions] = useState<AICompletion[]>([]);
  
  const { generateCodeCompletion, explainCode, debugCode } = useAIStore();

  const handleEditorDidMount: OnMount = useCallback((editor, monaco) => {
    editorRef.current = editor;
    setIsReady(true);

    // Enhanced editor configuration
    editor.updateOptions({
      fontSize: 14,
      fontFamily: 'JetBrains Mono, Consolas, Monaco, monospace',
      lineHeight: 1.6,
      minimap: { enabled: true },
      scrollBeyondLastLine: false,
      automaticLayout: true,
      tabSize: 2,
      insertSpaces: true,
      wordWrap: 'on',
      bracketPairColorization: { enabled: true },
      guides: {
        bracketPairs: true,
        indentation: true,
      },
      suggest: {
        showKeywords: true,
        showSnippets: true,
        showClasses: true,
        showFunctions: true,
        showVariables: true,
      },
      quickSuggestions: {
        other: true,
        comments: true,
        strings: true,
      },
      parameterHints: { enabled: true },
      formatOnPaste: true,
      formatOnType: true,
      readOnly,
    });

    // Setup AI features
    if (enableAI) {
      setupAIFeatures(editor, monaco);
    }

    // Setup collaboration
    if (enableCollaboration && projectId) {
      setupCollaboration(editor);
    }

    // Setup custom keybindings
    setupKeybindings(editor, monaco);
  }, [enableAI, enableCollaboration, projectId, readOnly]);

  const setupAIFeatures = (editor: monaco.editor.IStandaloneCodeEditor, monaco: any) => {
    // AI-powered code completion
    const completionProvider = monaco.languages.registerCompletionItemProvider(language, {
      provideCompletionItems: async (model: any, position: any) => {
        if (!enableAI || isLoadingCompletion) return { suggestions: [] };

        setIsLoadingCompletion(true);
        try {
          const textUntilPosition = model.getValueInRange({
            startLineNumber: Math.max(1, position.lineNumber - 10),
            startColumn: 1,
            endLineNumber: position.lineNumber,
            endColumn: position.column,
          });

          const completions = await generateCodeCompletion(textUntilPosition, language);
          
          const suggestions = completions.map((completion: string, index: number) => ({
            label: `âœ¨ AI Suggestion ${index + 1}`,
            kind: monaco.languages.CompletionItemKind.Text,
            insertText: completion,
            detail: 'AI-generated completion',
            documentation: 'Generated by AI assistant',
            sortText: `0${index}`, // Prioritize AI suggestions
            range: {
              startLineNumber: position.lineNumber,
              endLineNumber: position.lineNumber,
              startColumn: position.column,
              endColumn: position.column,
            },
          }));

          return { suggestions };
        } catch (error) {
          console.error('AI completion error:', error);
          return { suggestions: [] };
        } finally {
          setIsLoadingCompletion(false);
        }
      },
    });

    // AI code actions (quick fixes, refactoring)
    const codeActionProvider = monaco.languages.registerCodeActionProvider(language, {
      provideCodeActions: (model: any, range: any, context: any) => {
        const actions: any[] = [];

        // Add AI explain action
        actions.push({
          title: 'ðŸ¤– Explain with AI',
          kind: 'quickfix',
          edit: {
            edits: [],
          },
          command: {
            id: 'ai.explain',
            title: 'Explain Code',
            arguments: [model.getValueInRange(range)],
          },
        });

        // Add AI debug action if there are diagnostics
        if (context.markers && context.markers.length > 0) {
          actions.push({
            title: 'ðŸ”§ Debug with AI',
            kind: 'quickfix',
            edit: {
              edits: [],
            },
            command: {
              id: 'ai.debug',
              title: 'Debug Code',
              arguments: [model.getValueInRange(range), context.markers[0].message],
            },
          });
        }

        return {
          actions,
          dispose: () => {},
        };
      },
    });

    // Register AI commands
    editor.addCommand(monaco.KeyCode.F1, () => {
      // Command palette would show AI commands
    });

    return () => {
      completionProvider.dispose();
      codeActionProvider.dispose();
    };
  };

  const setupCollaboration = (editor: monaco.editor.IStandaloneCodeEditor) => {
    if (!socket || !isConnected) return;

    // Send cursor position changes
    editor.onDidChangeCursorPosition((e) => {
      socket.emit('cursor_position', {
        projectId,
        fileId: path,
        position: {
          line: e.position.lineNumber,
          column: e.position.column,
        },
      });
    });

    // Send content changes
    editor.onDidChangeModelContent((e) => {
      socket.emit('file_change', {
        projectId,
        fileId: path,
        changes: e.changes,
        versionId: e.versionId,
      });
    });

    // Listen for remote changes
    socket.on('file_change', (data: any) => {
      if (data.fileId === path && data.userId !== socket.id) {
        // Apply remote changes (would need operational transformation)
        console.log('Remote change received:', data);
      }
    });

    socket.on('cursor_position', (data: any) => {
      if (data.fileId === path && data.userId !== socket.id) {
        // Show remote cursors (would need cursor decorations)
        console.log('Remote cursor:', data);
      }
    });
  };

  const setupKeybindings = (editor: monaco.editor.IStandaloneCodeEditor, monaco: any) => {
    // AI Explain Code (Ctrl+Shift+E)
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyE, () => {
      const selection = editor.getSelection();
      if (selection && !selection.isEmpty()) {
        const selectedText = editor.getModel()?.getValueInRange(selection);
        if (selectedText) {
          handleExplainCode(selectedText);
        }
      }
    });

    // AI Debug Code (Ctrl+Shift+D)
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyD, () => {
      const selection = editor.getSelection();
      if (selection && !selection.isEmpty()) {
        const selectedText = editor.getModel()?.getValueInRange(selection);
        if (selectedText) {
          handleDebugCode(selectedText);
        }
      }
    });

    // Save (Ctrl+S)
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
      if (onSave) {
        onSave(editor.getValue());
      }
    });

    // Format Document (Ctrl+Shift+F)
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyF, () => {
      editor.getAction('editor.action.formatDocument')?.run();
    });
  };

  const handleExplainCode = async (code: string) => {
    try {
      const explanation = await explainCode(code, language);
      // Show explanation in a modal or notification
      console.log('Code explanation:', explanation);
      // TODO: Implement explanation display
    } catch (error) {
      console.error('Failed to explain code:', error);
    }
  };

  const handleDebugCode = async (code: string, error?: string) => {
    try {
      const debugSuggestion = await debugCode(code, error || 'Unknown error', language);
      // Show debug suggestion
      console.log('Debug suggestion:', debugSuggestion);
      // TODO: Implement debug suggestion display
    } catch (error) {
      console.error('Failed to debug code:', error);
    }
  };

  const handleEditorChange: OnChange = useCallback((value) => {
    if (onChange && value !== undefined) {
      onChange(value, []); // TODO: Extract actual changes
    }
  }, [onChange]);

  const getLanguageFromPath = (filePath: string): string => {
    const ext = filePath.split('.').pop()?.toLowerCase();
    const languageMap: Record<string, string> = {
      js: 'javascript',
      jsx: 'javascript',
      ts: 'typescript',
      tsx: 'typescript',
      py: 'python',
      java: 'java',
      cpp: 'cpp',
      c: 'c',
      cs: 'csharp',
      php: 'php',
      rb: 'ruby',
      go: 'go',
      rs: 'rust',
      html: 'html',
      css: 'css',
      scss: 'scss',
      json: 'json',
      xml: 'xml',
      yaml: 'yaml',
      yml: 'yaml',
      md: 'markdown',
      sql: 'sql',
    };
    return languageMap[ext || ''] || 'plaintext';
  };

  const detectedLanguage = language || getLanguageFromPath(path);
  const editorTheme = theme === 'dark' ? 'vs-dark' : 'vs-light';

  return (
    <div className={`w-full h-full relative ${className}`}>
      {isLoadingCompletion && (
        <div className="absolute top-2 right-2 z-10 bg-blue-500 text-white px-2 py-1 rounded text-xs flex items-center gap-1">
          <div className="animate-spin w-3 h-3 border border-white border-t-transparent rounded-full"></div>
          AI Completing...
        </div>
      )}
      <Editor
        height="100%"
        width="100%"
        language={detectedLanguage}
        value={value}
        theme={editorTheme}
        onChange={handleEditorChange}
        onMount={handleEditorDidMount}
        options={{
          readOnly,
          automaticLayout: true,
        }}
      />
    </div>
  );
};
